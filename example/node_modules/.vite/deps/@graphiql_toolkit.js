import {
  isAsyncIterable,
  makeAsyncIterableIteratorFromSink,
  t
} from "./chunk-XZLBJKVO.js";
import {
  Kind,
  TypeInfo,
  getNamedType,
  isLeafType,
  parse,
  print,
  visit,
  visitWithTypeInfo
} from "./chunk-LKNORULI.js";
import "./chunk-V4OQ3NZ2.js";

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/chunk-LMOQIXV4.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b))
      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __await = function(promise, isYieldStar) {
  this[0] = promise, this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/async-helpers/index.js
function isPromise(value) {
  return typeof value == "object" && value !== null && typeof value.then == "function";
}
function observableToPromise(observable) {
  return new Promise((resolve, reject) => {
    const subscription = observable.subscribe({
      next(v) {
        resolve(v), subscription.unsubscribe();
      },
      error: reject,
      complete() {
        reject(new Error("no value resolved"));
      }
    });
  });
}
function isObservable(value) {
  return typeof value == "object" && value !== null && "subscribe" in value && typeof value.subscribe == "function";
}
function isAsyncIterable2(input) {
  return typeof input == "object" && input !== null && // Some browsers still don't have Symbol.asyncIterator implemented (iOS Safari)
  // That means every custom AsyncIterable must be built using a AsyncGeneratorFunction (async function * () {})
  (input[Symbol.toStringTag] === "AsyncGenerator" || Symbol.asyncIterator in input);
}
async function asyncIterableToPromise(input) {
  var _a;
  const iteratorReturn = (_a = ("return" in input ? input : input[Symbol.asyncIterator]()).return) == null ? void 0 : _a.bind(input), result = await ("next" in input ? input : input[Symbol.asyncIterator]()).next.bind(input)();
  return iteratorReturn == null || iteratorReturn(), result.value;
}
async function fetcherReturnToPromise(fetcherResult) {
  const result = await fetcherResult;
  return isAsyncIterable2(result) ? asyncIterableToPromise(result) : isObservable(result) ? observableToPromise(result) : result;
}

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/create-fetcher/lib.js
var errorHasCode = (err) => typeof err == "object" && err !== null && "code" in err;
var isSubscriptionWithName = (document, name) => {
  let isSubscription = false;
  return visit(document, {
    OperationDefinition(node) {
      var _a;
      name === ((_a = node.name) == null ? void 0 : _a.value) && node.operation === "subscription" && (isSubscription = true);
    }
  }), isSubscription;
};
var createSimpleFetcher = (options, httpFetch) => async (graphQLParams, fetcherOpts) => (await httpFetch(options.url, {
  method: "POST",
  body: JSON.stringify(graphQLParams),
  headers: __spreadValues(__spreadValues({
    "content-type": "application/json"
  }, options.headers), fetcherOpts == null ? void 0 : fetcherOpts.headers)
})).json();
async function createWebsocketsFetcherFromUrl(url, connectionParams) {
  let wsClient;
  try {
    const { createClient } = await import("./toolkit-FEVFL24L.js");
    return wsClient = createClient({ url, connectionParams }), createWebsocketsFetcherFromClient(wsClient);
  } catch (err) {
    if (errorHasCode(err) && err.code === "MODULE_NOT_FOUND")
      throw new Error(
        "You need to install the 'graphql-ws' package to use websockets when passing a 'subscriptionUrl'"
      );
    console.error(`Error creating websocket client for ${url}`, err);
  }
}
var createWebsocketsFetcherFromClient = (wsClient) => (graphQLParams) => makeAsyncIterableIteratorFromSink(
  (sink) => wsClient.subscribe(graphQLParams, __spreadProps(__spreadValues({}, sink), {
    error(err) {
      err instanceof CloseEvent ? sink.error(
        new Error(
          `Socket closed with event ${err.code} ${err.reason || ""}`.trim()
        )
      ) : sink.error(err);
    }
  }))
);
var createLegacyWebsocketsFetcher = (legacyWsClient) => (graphQLParams) => {
  const observable = legacyWsClient.request(graphQLParams);
  return makeAsyncIterableIteratorFromSink(
    // @ts-ignore
    (sink) => observable.subscribe(sink).unsubscribe
  );
};
var createMultipartFetcher = (options, httpFetch) => function(graphQLParams, fetcherOpts) {
  return __asyncGenerator(this, null, function* () {
    const response = yield new __await(httpFetch(options.url, {
      method: "POST",
      body: JSON.stringify(graphQLParams),
      headers: __spreadValues(__spreadValues({
        "content-type": "application/json",
        accept: "application/json, multipart/mixed"
      }, options.headers), fetcherOpts == null ? void 0 : fetcherOpts.headers)
    }).then(
      (r) => t(r, {
        multiple: true
      })
    ));
    if (!isAsyncIterable(response))
      return yield response.json();
    try {
      for (var iter = __forAwait(response), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const chunk = temp.value;
        if (chunk.some((part) => !part.json)) {
          const message = chunk.map(
            (part) => `Headers::
${part.headers}

Body::
${part.body}`
          );
          throw new Error(
            `Expected multipart chunks to be of json type. got:
${message}`
          );
        }
        yield chunk.map((part) => part.body);
      }
    } catch (temp2) {
      error = [temp2];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
};
async function getWsFetcher(options, fetcherOpts) {
  if (options.wsClient)
    return createWebsocketsFetcherFromClient(options.wsClient);
  if (options.subscriptionUrl)
    return createWebsocketsFetcherFromUrl(options.subscriptionUrl, __spreadValues(__spreadValues({}, options.wsConnectionParams), fetcherOpts == null ? void 0 : fetcherOpts.headers));
  const legacyWebsocketsClient = options.legacyClient || options.legacyWsClient;
  if (legacyWebsocketsClient)
    return createLegacyWebsocketsFetcher(legacyWebsocketsClient);
}

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/create-fetcher/createFetcher.js
function createGraphiQLFetcher(options) {
  const httpFetch = options.fetch || typeof window != "undefined" && window.fetch;
  if (!httpFetch)
    throw new Error("No valid fetcher implementation available");
  options.enableIncrementalDelivery = options.enableIncrementalDelivery !== false;
  const simpleFetcher = createSimpleFetcher(options, httpFetch), httpFetcher = options.enableIncrementalDelivery ? createMultipartFetcher(options, httpFetch) : simpleFetcher;
  return async (graphQLParams, fetcherOpts) => {
    if (graphQLParams.operationName === "IntrospectionQuery")
      return (options.schemaFetcher || simpleFetcher)(
        graphQLParams,
        fetcherOpts
      );
    if (fetcherOpts != null && fetcherOpts.documentAST ? isSubscriptionWithName(
      fetcherOpts.documentAST,
      graphQLParams.operationName || void 0
    ) : false) {
      const wsFetcher = await getWsFetcher(options, fetcherOpts);
      if (!wsFetcher)
        throw new Error(
          `Your GraphiQL createFetcher is not properly configured for websocket subscriptions yet. ${options.subscriptionUrl ? `Provided URL ${options.subscriptionUrl} failed` : "Please provide subscriptionUrl, wsClient or legacyClient option first."}`
        );
      return wsFetcher(graphQLParams);
    }
    return httpFetcher(graphQLParams, fetcherOpts);
  };
}

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/format/index.js
function stringify(obj) {
  return JSON.stringify(obj, null, 2);
}
function formatSingleError(error) {
  return __spreadProps(__spreadValues({}, error), {
    // Raise these details even if they're non-enumerable
    message: error.message,
    stack: error.stack
  });
}
function handleSingleError(error) {
  return error instanceof Error ? formatSingleError(error) : error;
}
function formatError(error) {
  return Array.isArray(error) ? stringify({
    errors: error.map((e) => handleSingleError(e))
  }) : stringify({ errors: [handleSingleError(error)] });
}
function formatResult(result) {
  return stringify(result);
}

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/graphql-helpers/auto-complete.js
function fillLeafs(schema, docString, getDefaultFieldNames) {
  const insertions = [];
  if (!schema || !docString)
    return { insertions, result: docString };
  let ast;
  try {
    ast = parse(docString);
  } catch (e) {
    return { insertions, result: docString };
  }
  const fieldNameFn = getDefaultFieldNames || defaultGetDefaultFieldNames, typeInfo = new TypeInfo(schema);
  return visit(ast, {
    leave(node) {
      typeInfo.leave(node);
    },
    enter(node) {
      if (typeInfo.enter(node), node.kind === "Field" && !node.selectionSet) {
        const fieldType = typeInfo.getType(), selectionSet = buildSelectionSet(
          isFieldType(fieldType),
          fieldNameFn
        );
        if (selectionSet && node.loc) {
          const indent = getIndentation(docString, node.loc.start);
          insertions.push({
            index: node.loc.end,
            string: " " + print(selectionSet).replaceAll(`
`, `
` + indent)
          });
        }
      }
    }
  }), {
    insertions,
    result: withInsertions(docString, insertions)
  };
}
function defaultGetDefaultFieldNames(type) {
  if (!("getFields" in type))
    return [];
  const fields = type.getFields();
  if (fields.id)
    return ["id"];
  if (fields.edges)
    return ["edges"];
  if (fields.node)
    return ["node"];
  const leafFieldNames = [];
  for (const fieldName of Object.keys(fields))
    isLeafType(fields[fieldName].type) && leafFieldNames.push(fieldName);
  return leafFieldNames;
}
function buildSelectionSet(type, getDefaultFieldNames) {
  const namedType = getNamedType(type);
  if (!type || isLeafType(type))
    return;
  const fieldNames = getDefaultFieldNames(namedType);
  if (!(!Array.isArray(fieldNames) || fieldNames.length === 0 || !("getFields" in namedType)))
    return {
      kind: Kind.SELECTION_SET,
      selections: fieldNames.map((fieldName) => {
        const fieldDef = namedType.getFields()[fieldName], fieldType = fieldDef ? fieldDef.type : null;
        return {
          kind: Kind.FIELD,
          name: {
            kind: Kind.NAME,
            value: fieldName
          },
          // we can use as here, because we already know that fieldType
          // comes from an origin parameter
          selectionSet: buildSelectionSet(fieldType, getDefaultFieldNames)
        };
      })
    };
}
function withInsertions(initial, insertions) {
  if (insertions.length === 0)
    return initial;
  let edited = "", prevIndex = 0;
  for (const { index, string } of insertions)
    edited += initial.slice(prevIndex, index) + string, prevIndex = index;
  return edited += initial.slice(prevIndex), edited;
}
function getIndentation(str, index) {
  let indentStart = index, indentEnd = index;
  for (; indentStart; ) {
    const c = str.charCodeAt(indentStart - 1);
    if (c === 10 || c === 13 || c === 8232 || c === 8233)
      break;
    indentStart--, c !== 9 && c !== 11 && c !== 12 && c !== 32 && c !== 160 && (indentEnd = indentStart);
  }
  return str.slice(indentStart, indentEnd);
}
function isFieldType(fieldType) {
  if (fieldType)
    return fieldType;
}

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/graphql-helpers/merge-ast.js
function uniqueBy(array, iteratee) {
  var _a;
  const FilteredMap = /* @__PURE__ */ new Map(), result = [];
  for (const item of array)
    if (item.kind === "Field") {
      const uniqueValue = iteratee(item), existing = FilteredMap.get(uniqueValue);
      if ((_a = item.directives) != null && _a.length) {
        const itemClone = __spreadValues({}, item);
        result.push(itemClone);
      } else if (existing != null && existing.selectionSet && item.selectionSet)
        existing.selectionSet.selections = [
          ...existing.selectionSet.selections,
          ...item.selectionSet.selections
        ];
      else if (!existing) {
        const itemClone = __spreadValues({}, item);
        FilteredMap.set(uniqueValue, itemClone), result.push(itemClone);
      }
    } else
      result.push(item);
  return result;
}
function inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType) {
  var _a;
  const selectionSetTypeName = selectionSetType ? getNamedType(selectionSetType).name : null, outputSelections = [], seenSpreads = [];
  for (let selection of selections) {
    if (selection.kind === "FragmentSpread") {
      const fragmentName = selection.name.value;
      if (!selection.directives || selection.directives.length === 0) {
        if (seenSpreads.includes(fragmentName))
          continue;
        seenSpreads.push(fragmentName);
      }
      const fragmentDefinition = fragmentDefinitions[selection.name.value];
      if (fragmentDefinition) {
        const { typeCondition, directives, selectionSet } = fragmentDefinition;
        selection = {
          kind: Kind.INLINE_FRAGMENT,
          typeCondition,
          directives,
          selectionSet
        };
      }
    }
    if (selection.kind === Kind.INLINE_FRAGMENT && // Cannot inline if there are directives
    (!selection.directives || ((_a = selection.directives) == null ? void 0 : _a.length) === 0)) {
      const fragmentTypeName = selection.typeCondition ? selection.typeCondition.name.value : null;
      if (!fragmentTypeName || fragmentTypeName === selectionSetTypeName) {
        outputSelections.push(
          ...inlineRelevantFragmentSpreads(
            fragmentDefinitions,
            selection.selectionSet.selections,
            selectionSetType
          )
        );
        continue;
      }
    }
    outputSelections.push(selection);
  }
  return outputSelections;
}
function mergeAst(documentAST, schema) {
  const typeInfo = schema ? new TypeInfo(schema) : null, fragmentDefinitions = /* @__PURE__ */ Object.create(null);
  for (const definition of documentAST.definitions)
    definition.kind === Kind.FRAGMENT_DEFINITION && (fragmentDefinitions[definition.name.value] = definition);
  const flattenVisitors = {
    SelectionSet(node) {
      const selectionSetType = typeInfo ? typeInfo.getParentType() : null;
      let { selections } = node;
      return selections = inlineRelevantFragmentSpreads(
        fragmentDefinitions,
        selections,
        selectionSetType
      ), __spreadProps(__spreadValues({}, node), {
        selections
      });
    },
    FragmentDefinition() {
      return null;
    }
  }, flattenedAST = visit(
    documentAST,
    typeInfo ? visitWithTypeInfo(typeInfo, flattenVisitors) : flattenVisitors
  );
  return visit(flattenedAST, {
    SelectionSet(node) {
      let { selections } = node;
      return selections = uniqueBy(
        selections,
        (selection) => selection.alias ? selection.alias.value : selection.name.value
      ), __spreadProps(__spreadValues({}, node), {
        selections
      });
    },
    FragmentDefinition() {
      return null;
    }
  });
}

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/graphql-helpers/operation-name.js
function getSelectedOperationName(prevOperations, prevSelectedOperationName, operations) {
  if (!operations || operations.length < 1)
    return;
  const names = operations.map((op) => {
    var _a;
    return (_a = op.name) == null ? void 0 : _a.value;
  });
  if (prevSelectedOperationName && names.includes(prevSelectedOperationName))
    return prevSelectedOperationName;
  if (prevSelectedOperationName && prevOperations) {
    const prevIndex = prevOperations.map((op) => {
      var _a;
      return (_a = op.name) == null ? void 0 : _a.value;
    }).indexOf(prevSelectedOperationName);
    if (prevIndex !== -1 && prevIndex < names.length)
      return names[prevIndex];
  }
  return names[0];
}

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/storage/base.js
function isQuotaError(storage, e) {
  return e instanceof DOMException && // everything except Firefox
  (e.code === 22 || // Firefox
  e.code === 1014 || // test name field too, because code might not be present
  // everything except Firefox
  e.name === "QuotaExceededError" || // Firefox
  e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
  storage.length !== 0;
}
var StorageAPI = class {
  constructor(storage) {
    storage ? this.storage = storage : storage === null ? this.storage = null : typeof window == "undefined" ? this.storage = null : this.storage = {
      getItem: localStorage.getItem.bind(localStorage),
      setItem: localStorage.setItem.bind(localStorage),
      removeItem: localStorage.removeItem.bind(localStorage),
      get length() {
        let keys = 0;
        for (const key in localStorage)
          key.indexOf(`${STORAGE_NAMESPACE}:`) === 0 && (keys += 1);
        return keys;
      },
      clear() {
        for (const key in localStorage)
          key.indexOf(`${STORAGE_NAMESPACE}:`) === 0 && localStorage.removeItem(key);
      }
    };
  }
  get(name) {
    if (!this.storage)
      return null;
    const key = `${STORAGE_NAMESPACE}:${name}`, value = this.storage.getItem(key);
    return value === "null" || value === "undefined" ? (this.storage.removeItem(key), null) : value || null;
  }
  set(name, value) {
    let quotaError = false, error = null;
    if (this.storage) {
      const key = `${STORAGE_NAMESPACE}:${name}`;
      if (value)
        try {
          this.storage.setItem(key, value);
        } catch (e) {
          error = e instanceof Error ? e : new Error(`${e}`), quotaError = isQuotaError(this.storage, e);
        }
      else
        this.storage.removeItem(key);
    }
    return { isQuotaError: quotaError, error };
  }
  clear() {
    this.storage && this.storage.clear();
  }
};
var STORAGE_NAMESPACE = "graphiql";

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/storage/query.js
var QueryStore = class {
  constructor(key, storage, maxSize = null) {
    this.key = key;
    this.storage = storage;
    this.maxSize = maxSize;
    this.items = this.fetchAll();
  }
  get length() {
    return this.items.length;
  }
  contains(item) {
    return this.items.some(
      (x) => x.query === item.query && x.variables === item.variables && x.headers === item.headers && x.operationName === item.operationName
    );
  }
  edit(item, index) {
    if (typeof index == "number" && this.items[index]) {
      const found = this.items[index];
      if (found.query === item.query && found.variables === item.variables && found.headers === item.headers && found.operationName === item.operationName) {
        this.items.splice(index, 1, item), this.save();
        return;
      }
    }
    const itemIndex = this.items.findIndex(
      (x) => x.query === item.query && x.variables === item.variables && x.headers === item.headers && x.operationName === item.operationName
    );
    itemIndex !== -1 && (this.items.splice(itemIndex, 1, item), this.save());
  }
  delete(item) {
    const itemIndex = this.items.findIndex(
      (x) => x.query === item.query && x.variables === item.variables && x.headers === item.headers && x.operationName === item.operationName
    );
    itemIndex !== -1 && (this.items.splice(itemIndex, 1), this.save());
  }
  fetchRecent() {
    return this.items.at(-1);
  }
  fetchAll() {
    const raw = this.storage.get(this.key);
    return raw ? JSON.parse(raw)[this.key] : [];
  }
  push(item) {
    const items = [...this.items, item];
    this.maxSize && items.length > this.maxSize && items.shift();
    for (let attempts = 0; attempts < 5; attempts++) {
      const response = this.storage.set(
        this.key,
        JSON.stringify({ [this.key]: items })
      );
      if (!(response != null && response.error))
        this.items = items;
      else if (response.isQuotaError && this.maxSize)
        items.shift();
      else
        return;
    }
  }
  save() {
    this.storage.set(this.key, JSON.stringify({ [this.key]: this.items }));
  }
};

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/storage/history.js
var MAX_QUERY_SIZE = 1e5;
var HistoryStore = class {
  constructor(storage, maxHistoryLength) {
    this.storage = storage;
    this.maxHistoryLength = maxHistoryLength;
    this.updateHistory = ({
      query,
      variables,
      headers,
      operationName
    }) => {
      if (!this.shouldSaveQuery(
        query,
        variables,
        headers,
        this.history.fetchRecent()
      ))
        return;
      this.history.push({
        query,
        variables,
        headers,
        operationName
      });
      const historyQueries = this.history.items, favoriteQueries = this.favorite.items;
      this.queries = historyQueries.concat(favoriteQueries);
    };
    this.deleteHistory = ({ query, variables, headers, operationName, favorite }, clearFavorites = false) => {
      function deleteFromStore(store) {
        const found = store.items.find(
          (x) => x.query === query && x.variables === variables && x.headers === headers && x.operationName === operationName
        );
        found && store.delete(found);
      }
      (favorite || clearFavorites) && deleteFromStore(this.favorite), (!favorite || clearFavorites) && deleteFromStore(this.history), this.queries = [...this.history.items, ...this.favorite.items];
    };
    this.history = new QueryStore(
      "queries",
      this.storage,
      this.maxHistoryLength
    ), this.favorite = new QueryStore("favorites", this.storage, null), this.queries = [...this.history.fetchAll(), ...this.favorite.fetchAll()];
  }
  shouldSaveQuery(query, variables, headers, lastQuerySaved) {
    if (!query)
      return false;
    try {
      parse(query);
    } catch (e) {
      return false;
    }
    return query.length > MAX_QUERY_SIZE ? false : lastQuerySaved ? !(JSON.stringify(query) === JSON.stringify(lastQuerySaved.query) && (JSON.stringify(variables) === JSON.stringify(lastQuerySaved.variables) && (JSON.stringify(headers) === JSON.stringify(lastQuerySaved.headers) || headers && !lastQuerySaved.headers) || variables && !lastQuerySaved.variables)) : true;
  }
  toggleFavorite({
    query,
    variables,
    headers,
    operationName,
    label,
    favorite
  }) {
    const item = {
      query,
      variables,
      headers,
      operationName,
      label
    };
    favorite ? (item.favorite = false, this.favorite.delete(item), this.history.push(item)) : (item.favorite = true, this.favorite.push(item), this.history.delete(item)), this.queries = [...this.history.items, ...this.favorite.items];
  }
  editLabel({
    query,
    variables,
    headers,
    operationName,
    label,
    favorite
  }, index) {
    const item = {
      query,
      variables,
      headers,
      operationName,
      label
    };
    favorite ? this.favorite.edit(__spreadProps(__spreadValues({}, item), { favorite }), index) : this.history.edit(item, index), this.queries = [...this.history.items, ...this.favorite.items];
  }
};

// node_modules/.pnpm/@graphiql+toolkit@0.11.1_graphql@16.11.0/node_modules/@graphiql/toolkit/dist/esm/storage/custom.js
function createLocalStorage({
  namespace
}) {
  const storageKeyPrefix = `${namespace}:`, getStorageKey = (key) => `${storageKeyPrefix}${key}`;
  return {
    setItem: (key, value) => localStorage.setItem(getStorageKey(key), value),
    getItem: (key) => localStorage.getItem(getStorageKey(key)),
    removeItem: (key) => localStorage.removeItem(getStorageKey(key)),
    get length() {
      let keys = 0;
      for (const key in localStorage)
        key.indexOf(storageKeyPrefix) === 0 && (keys += 1);
      return keys;
    },
    clear() {
      for (const key in localStorage)
        key.indexOf(storageKeyPrefix) === 0 && localStorage.removeItem(key);
    }
  };
}
export {
  HistoryStore,
  QueryStore,
  StorageAPI,
  createGraphiQLFetcher,
  createLocalStorage,
  fetcherReturnToPromise,
  fillLeafs,
  formatError,
  formatResult,
  getSelectedOperationName,
  isAsyncIterable2 as isAsyncIterable,
  isObservable,
  isPromise,
  mergeAst
};
//# sourceMappingURL=@graphiql_toolkit.js.map
