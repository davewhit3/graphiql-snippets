{
  "version": 3,
  "sources": ["../../.pnpm/codemirror-graphql@2.2.1_@codemirror+language@6.0.0_codemirror@5.65.19_graphql@16.11.0/node_modules/codemirror-graphql/src/utils/getTypeInfo.ts", "../../.pnpm/codemirror-graphql@2.2.1_@codemirror+language@6.0.0_codemirror@5.65.19_graphql@16.11.0/node_modules/codemirror-graphql/src/utils/SchemaReference.ts"],
  "sourcesContent": ["/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport {\n  isCompositeType,\n  getNullableType,\n  getNamedType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLList,\n  GraphQLSchema,\n  GraphQLType,\n  GraphQLObjectType,\n  GraphQLField,\n  GraphQLDirective,\n  GraphQLArgument,\n  GraphQLInputType,\n  GraphQLEnumValue,\n  GraphQLInputFieldMap,\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n} from 'graphql';\nimport type { State, Maybe } from 'graphql-language-service';\nimport forEachState from './forEachState';\n\nexport interface TypeInfo {\n  schema: GraphQLSchema;\n  type?: Maybe<GraphQLType>;\n  parentType?: Maybe<GraphQLType>;\n  inputType?: Maybe<GraphQLInputType>;\n  directiveDef?: Maybe<GraphQLDirective>;\n  fieldDef?: Maybe<GraphQLField<any, any>>;\n  argDef?: Maybe<GraphQLArgument>;\n  argDefs?: Maybe<GraphQLArgument[]>;\n  enumValue?: Maybe<GraphQLEnumValue>;\n  objectFieldDefs?: Maybe<GraphQLInputFieldMap>;\n}\n\n/**\n * Utility for collecting rich type information given any token's state\n * from the graphql-mode parser.\n */\nexport default function getTypeInfo(schema: GraphQLSchema, tokenState: State) {\n  const info: TypeInfo = {\n    schema,\n    type: null,\n    parentType: null,\n    inputType: null,\n    directiveDef: null,\n    fieldDef: null,\n    argDef: null,\n    argDefs: null,\n    objectFieldDefs: null,\n  };\n\n  forEachState(tokenState, (state: State) => {\n    switch (state.kind) {\n      case 'Query':\n      case 'ShortQuery':\n        info.type = schema.getQueryType();\n        break;\n      case 'Mutation':\n        info.type = schema.getMutationType();\n        break;\n      case 'Subscription':\n        info.type = schema.getSubscriptionType();\n        break;\n      case 'InlineFragment':\n      case 'FragmentDefinition':\n        if (state.type) {\n          info.type = schema.getType(state.type);\n        }\n        break;\n      case 'Field':\n      case 'AliasedField':\n        info.fieldDef =\n          info.type && state.name\n            ? getFieldDef(schema, info.parentType, state.name)\n            : null;\n        info.type = info.fieldDef?.type;\n        break;\n      case 'SelectionSet':\n        info.parentType = info.type ? getNamedType(info.type) : null;\n        break;\n      case 'Directive':\n        info.directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n      case 'Arguments':\n        const parentDef = state.prevState\n          ? state.prevState.kind === 'Field'\n            ? info.fieldDef\n            : state.prevState.kind === 'Directive'\n              ? info.directiveDef\n              : state.prevState.kind === 'AliasedField'\n                ? state.prevState.name &&\n                  getFieldDef(schema, info.parentType, state.prevState.name)\n                : null\n          : null;\n        info.argDefs = parentDef ? (parentDef.args as GraphQLArgument[]) : null;\n        break;\n      case 'Argument':\n        info.argDef = null;\n        if (info.argDefs) {\n          for (let i = 0; i < info.argDefs.length; i++) {\n            if (info.argDefs[i].name === state.name) {\n              info.argDef = info.argDefs[i];\n              break;\n            }\n          }\n        }\n        info.inputType = info.argDef?.type;\n        break;\n      case 'EnumValue':\n        const enumType = info.inputType ? getNamedType(info.inputType) : null;\n        info.enumValue =\n          enumType instanceof GraphQLEnumType\n            ? find(\n                enumType.getValues() as GraphQLEnumValue[],\n                val => val.value === state.name,\n              )\n            : null;\n        break;\n      case 'ListValue':\n        const nullableType = info.inputType\n          ? getNullableType(info.inputType)\n          : null;\n        info.inputType =\n          nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n      case 'ObjectValue':\n        const objectType = info.inputType ? getNamedType(info.inputType) : null;\n        info.objectFieldDefs =\n          objectType instanceof GraphQLInputObjectType\n            ? objectType.getFields()\n            : null;\n        break;\n      case 'ObjectField':\n        const objectField =\n          state.name && info.objectFieldDefs\n            ? info.objectFieldDefs[state.name]\n            : null;\n        info.inputType = objectField?.type;\n        // @ts-expect-error\n        info.fieldDef = objectField;\n        break;\n      case 'NamedType':\n        info.type = state.name ? schema.getType(state.name) : null;\n        break;\n    }\n  });\n\n  return info;\n}\n\n// Gets the field definition given a type and field name\nfunction getFieldDef(\n  schema: GraphQLSchema,\n  type: Maybe<GraphQLType>,\n  fieldName: string,\n) {\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n    return SchemaMetaFieldDef;\n  }\n  if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type) {\n    return TypeMetaFieldDef;\n  }\n  if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (type && (type as GraphQLObjectType).getFields) {\n    return (type as GraphQLObjectType).getFields()[fieldName];\n  }\n}\n\n// Returns the first item in the array which causes predicate to return truthy.\nfunction find<T>(array: T[], predicate: (item: T) => boolean) {\n  for (let i = 0; i < array.length; i++) {\n    if (predicate(array[i])) {\n      return array[i];\n    }\n  }\n}\n", "/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport { getNamedType, GraphQLSchema } from 'graphql';\n\nimport type {\n  GraphQLArgument,\n  GraphQLDirective,\n  GraphQLEnumValue,\n  GraphQLEnumType,\n  GraphQLField,\n  GraphQLNamedType,\n} from 'graphql';\nimport { Maybe } from 'graphql/jsutils/Maybe';\nimport { TypeInfo } from './getTypeInfo';\n\nexport type SchemaReference =\n  | FieldReference\n  | DirectiveReference\n  | ArgumentReference\n  | EnumValueReference\n  | TypeReference;\n\nexport type FieldReference = {\n  kind: 'Field';\n  field: GraphQLField<any, any>;\n  type: Maybe<GraphQLNamedType>;\n  schema?: GraphQLSchema;\n};\n\nexport type DirectiveReference = {\n  kind: 'Directive';\n  directive: GraphQLDirective;\n  schema?: GraphQLSchema;\n};\n\nexport type ArgumentReference = {\n  kind: 'Argument';\n  argument: GraphQLArgument;\n  field?: GraphQLField<any, any>;\n  type?: GraphQLNamedType;\n  directive?: GraphQLDirective;\n  schema?: GraphQLSchema;\n};\n\nexport type EnumValueReference = {\n  kind: 'EnumValue';\n  value?: GraphQLEnumValue;\n  type?: GraphQLEnumType;\n  schema?: GraphQLSchema;\n};\n\nexport type TypeReference = {\n  kind: 'Type';\n  type: GraphQLNamedType;\n  schema?: GraphQLSchema;\n};\n\nexport function getFieldReference(typeInfo: any): FieldReference {\n  return {\n    kind: 'Field',\n    schema: typeInfo.schema,\n    field: typeInfo.fieldDef,\n    type: isMetaField(typeInfo.fieldDef) ? null : typeInfo.parentType,\n  };\n}\n\nexport function getDirectiveReference(typeInfo: any): DirectiveReference {\n  return {\n    kind: 'Directive',\n    schema: typeInfo.schema,\n    directive: typeInfo.directiveDef,\n  };\n}\n\nexport function getArgumentReference(typeInfo: any): ArgumentReference {\n  return typeInfo.directiveDef\n    ? {\n        kind: 'Argument',\n        schema: typeInfo.schema,\n        argument: typeInfo.argDef,\n        directive: typeInfo.directiveDef,\n      }\n    : {\n        kind: 'Argument',\n        schema: typeInfo.schema,\n        argument: typeInfo.argDef,\n        field: typeInfo.fieldDef,\n        type: isMetaField(typeInfo.fieldDef) ? null : typeInfo.parentType,\n      };\n}\n\nexport function getEnumValueReference(typeInfo: TypeInfo): EnumValueReference {\n  return {\n    kind: 'EnumValue',\n    value: typeInfo.enumValue || undefined,\n    // $FlowFixMe\n    type: typeInfo.inputType\n      ? (getNamedType(typeInfo.inputType) as GraphQLEnumType)\n      : undefined,\n  };\n}\n\n// Note: for reusability, getTypeReference can produce a reference to any type,\n// though it defaults to the current type.\nexport function getTypeReference(\n  typeInfo: any,\n  type?: Maybe<GraphQLNamedType>,\n): TypeReference {\n  return {\n    kind: 'Type',\n    schema: typeInfo.schema,\n    type: type || typeInfo.type,\n  };\n}\n\nfunction isMetaField(fieldDef: GraphQLField<any, any>) {\n  return fieldDef.name.slice(0, 2) === '__';\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;AAiDc,SAAP,YAA6B,QAAuB,YAAiB;AAC1E,QAAM,OAAiB;IACrB;IACA,MAAM;IACN,YAAY;IACZ,WAAW;IACX,cAAc;IACd,UAAU;IACV,QAAQ;IACR,SAAS;IACT,iBAAiB;;AAGnB,eAAa,YAAY,CAAC,UAAgB;;AACxC,YAAQ,MAAM,MAAM;MAClB,KAAK;MACL,KAAK;AACH,aAAK,OAAO,OAAO,aAAY;AAC/B;MACF,KAAK;AACH,aAAK,OAAO,OAAO,gBAAe;AAClC;MACF,KAAK;AACH,aAAK,OAAO,OAAO,oBAAmB;AACtC;MACF,KAAK;MACL,KAAK;AACH,YAAI,MAAM,MAAM;AACd,eAAK,OAAO,OAAO,QAAQ,MAAM,IAAI;;AAEvC;MACF,KAAK;MACL,KAAK;AACH,aAAK,WACH,KAAK,QAAQ,MAAM,OACf,YAAY,QAAQ,KAAK,YAAY,MAAM,IAAI,IAC/C;AACN,aAAK,QAAO,KAAA,KAAK,cAAQ,QAAA,OAAA,SAAA,SAAA,GAAE;AAC3B;MACF,KAAK;AACH,aAAK,aAAa,KAAK,OAAO,aAAa,KAAK,IAAI,IAAI;AACxD;MACF,KAAK;AACH,aAAK,eAAe,MAAM,OAAO,OAAO,aAAa,MAAM,IAAI,IAAI;AACnE;MACF,KAAK;AACH,cAAM,YAAY,MAAM,YACpB,MAAM,UAAU,SAAS,UACvB,KAAK,WACL,MAAM,UAAU,SAAS,cACvB,KAAK,eACL,MAAM,UAAU,SAAS,iBACvB,MAAM,UAAU,QAChB,YAAY,QAAQ,KAAK,YAAY,MAAM,UAAU,IAAI,IACzD,OACN;AACJ,aAAK,UAAU,YAAa,UAAU,OAA6B;AACnE;MACF,KAAK;AACH,aAAK,SAAS;AACd,YAAI,KAAK,SAAS;AAChB,mBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KAAK;AAC5C,gBAAI,KAAK,QAAQ,CAAC,EAAE,SAAS,MAAM,MAAM;AACvC,mBAAK,SAAS,KAAK,QAAQ,CAAC;AAC5B;;;;AAIN,aAAK,aAAY,KAAA,KAAK,YAAM,QAAA,OAAA,SAAA,SAAA,GAAE;AAC9B;MACF,KAAK;AACH,cAAM,WAAW,KAAK,YAAY,aAAa,KAAK,SAAS,IAAI;AACjE,aAAK,YACH,oBAAoB,kBAChB,KACE,SAAS,UAAS,GAClB,SAAO,IAAI,UAAU,MAAM,IAAI,IAEjC;AACN;MACF,KAAK;AACH,cAAM,eAAe,KAAK,YACtB,gBAAgB,KAAK,SAAS,IAC9B;AACJ,aAAK,YACH,wBAAwB,cAAc,aAAa,SAAS;AAC9D;MACF,KAAK;AACH,cAAM,aAAa,KAAK,YAAY,aAAa,KAAK,SAAS,IAAI;AACnE,aAAK,kBACH,sBAAsB,yBAClB,WAAW,UAAS,IACpB;AACN;MACF,KAAK;AACH,cAAM,cACJ,MAAM,QAAQ,KAAK,kBACf,KAAK,gBAAgB,MAAM,IAAI,IAC/B;AACN,aAAK,YAAY,gBAAW,QAAX,gBAAW,SAAA,SAAX,YAAa;AAE9B,aAAK,WAAW;AAChB;MACF,KAAK;AACH,aAAK,OAAO,MAAM,OAAO,OAAO,QAAQ,MAAM,IAAI,IAAI;AACtD;;EAEN,CAAC;AAED,SAAO;AACT;AAGA,SAAS,YACP,QACA,MACA,WAAiB;AAEjB,MAAI,cAAc,mBAAmB,QAAQ,OAAO,aAAY,MAAO,MAAM;AAC3E,WAAO;;AAET,MAAI,cAAc,iBAAiB,QAAQ,OAAO,aAAY,MAAO,MAAM;AACzE,WAAO;;AAET,MAAI,cAAc,qBAAqB,QAAQ,gBAAgB,IAAI,GAAG;AACpE,WAAO;;AAET,MAAI,QAAS,KAA2B,WAAW;AACjD,WAAQ,KAA2B,UAAS,EAAG,SAAS;;AAE5D;AAGA,SAAS,KAAQ,OAAY,WAA+B;AAC1D,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,QAAI,UAAU,MAAM,CAAC,CAAC,GAAG;AACvB,aAAO,MAAM,CAAC;;;AAGpB;;;AC5HM,SAAU,kBAAkB,UAAa;AAC7C,SAAO;IACL,MAAM;IACN,QAAQ,SAAS;IACjB,OAAO,SAAS;IAChB,MAAM,YAAY,SAAS,QAAQ,IAAI,OAAO,SAAS;;AAE3D;AAEM,SAAU,sBAAsB,UAAa;AACjD,SAAO;IACL,MAAM;IACN,QAAQ,SAAS;IACjB,WAAW,SAAS;;AAExB;AAEM,SAAU,qBAAqB,UAAa;AAChD,SAAO,SAAS,eACZ;IACE,MAAM;IACN,QAAQ,SAAS;IACjB,UAAU,SAAS;IACnB,WAAW,SAAS;MAEtB;IACE,MAAM;IACN,QAAQ,SAAS;IACjB,UAAU,SAAS;IACnB,OAAO,SAAS;IAChB,MAAM,YAAY,SAAS,QAAQ,IAAI,OAAO,SAAS;;AAE/D;AAEM,SAAU,sBAAsB,UAAkB;AACtD,SAAO;IACL,MAAM;IACN,OAAO,SAAS,aAAa;IAE7B,MAAM,SAAS,YACV,aAAa,SAAS,SAAS,IAChC;;AAER;AAIM,SAAU,iBACd,UACA,MAA8B;AAE9B,SAAO;IACL,MAAM;IACN,QAAQ,SAAS;IACjB,MAAM,QAAQ,SAAS;;AAE3B;AAEA,SAAS,YAAY,UAAgC;AACnD,SAAO,SAAS,KAAK,MAAM,GAAG,CAAC,MAAM;AACvC;",
  "names": []
}
