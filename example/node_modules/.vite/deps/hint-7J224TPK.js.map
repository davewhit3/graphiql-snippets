{
  "version": 3,
  "sources": ["../../.pnpm/codemirror-graphql@2.2.1_@codemirror+language@6.0.0_codemirror@5.65.19_graphql@16.11.0/node_modules/codemirror-graphql/src/variables/hint.ts", "../../.pnpm/codemirror-graphql@2.2.1_@codemirror+language@6.0.0_codemirror@5.65.19_graphql@16.11.0/node_modules/codemirror-graphql/src/utils/hintList.ts"],
  "sourcesContent": ["/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport CodeMirror, { Hints } from 'codemirror';\nimport {\n  getNullableType,\n  getNamedType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLList,\n  GraphQLBoolean,\n  GraphQLInputType,\n  GraphQLInputFieldMap,\n} from 'graphql';\nimport type { State, Maybe } from 'graphql-language-service';\nimport { IHints } from '../hint';\n\nimport forEachState from '../utils/forEachState';\nimport hintList from '../utils/hintList';\n\nexport type VariableToType = Record<string, GraphQLInputType>;\ninterface GraphQLVariableHintOptions {\n  variableToType: VariableToType;\n}\n\ndeclare module 'codemirror' {\n  interface ShowHintOptions {\n    variableToType?: VariableToType;\n  }\n\n  interface CodeMirrorHintMap {\n    'graphql-variables': (\n      editor: CodeMirror.Editor,\n      options: GraphQLVariableHintOptions,\n    ) => IHints | undefined;\n  }\n}\n\n/**\n * Registers a \"hint\" helper for CodeMirror.\n *\n * Using CodeMirror's \"hint\" addon: https://codemirror.net/demo/complete.html\n * Given an editor, this helper will take the token at the cursor and return a\n * list of suggested tokens.\n *\n * Options:\n *\n *   - variableToType: { [variable: string]: GraphQLInputType }\n *\n * Additional Events:\n *\n *   - hasCompletion (codemirror, data, token) - signaled when the hinter has a\n *     new list of completion suggestions.\n *\n */\nCodeMirror.registerHelper(\n  'hint',\n  'graphql-variables',\n  (\n    editor: CodeMirror.Editor,\n    options: GraphQLVariableHintOptions,\n  ): Hints | undefined => {\n    const cur = editor.getCursor();\n    const token = editor.getTokenAt(cur);\n\n    const results = getVariablesHint(cur, token, options);\n    if (results?.list && results.list.length > 0) {\n      results.from = CodeMirror.Pos(results.from.line, results.from.ch);\n      results.to = CodeMirror.Pos(results.to.line, results.to.ch);\n      CodeMirror.signal(editor, 'hasCompletion', editor, results, token);\n    }\n\n    return results;\n  },\n);\n\nfunction getVariablesHint(\n  cur: CodeMirror.Position,\n  token: CodeMirror.Token,\n  options: GraphQLVariableHintOptions,\n) {\n  // If currently parsing an invalid state, attempt to hint to the prior state.\n  const state =\n    token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n\n  const { kind, step } = state;\n  // Variables can only be an object literal.\n  if (kind === 'Document' && step === 0) {\n    return hintList(cur, token, [{ text: '{' }]);\n  }\n\n  const { variableToType } = options;\n  if (!variableToType) {\n    return;\n  }\n\n  const typeInfo = getTypeInfo(variableToType, token.state);\n\n  // Top level should typeahead possible variables.\n  if (kind === 'Document' || (kind === 'Variable' && step === 0)) {\n    const variableNames = Object.keys(variableToType);\n    return hintList(\n      cur,\n      token,\n      variableNames.map(name => ({\n        text: `\"${name}\": `,\n        type: variableToType[name],\n      })),\n    );\n  }\n\n  // Input Object fields\n  if (\n    (kind === 'ObjectValue' || (kind === 'ObjectField' && step === 0)) &&\n    typeInfo.fields\n  ) {\n    const inputFields = Object.keys(typeInfo.fields).map(\n      fieldName => typeInfo.fields![fieldName],\n    );\n    return hintList(\n      cur,\n      token,\n      inputFields.map(field => ({\n        text: `\"${field.name}\": `,\n        type: field.type,\n        description: field.description,\n      })),\n    );\n  }\n\n  // Input values.\n  if (\n    kind === 'StringValue' ||\n    kind === 'NumberValue' ||\n    kind === 'BooleanValue' ||\n    kind === 'NullValue' ||\n    (kind === 'ListValue' && step === 1) ||\n    (kind === 'ObjectField' && step === 2) ||\n    (kind === 'Variable' && step === 2)\n  ) {\n    const namedInputType = typeInfo.type\n      ? getNamedType(typeInfo.type)\n      : undefined;\n    if (namedInputType instanceof GraphQLInputObjectType) {\n      return hintList(cur, token, [{ text: '{' }]);\n    }\n    if (namedInputType instanceof GraphQLEnumType) {\n      const values = namedInputType.getValues();\n      // const values = Object.keys(valueMap).map(name => valueMap[name]); // TODO: Previously added\n      return hintList(\n        cur,\n        token,\n        values.map(value => ({\n          text: `\"${value.name}\"`,\n          type: namedInputType,\n          description: value.description,\n        })),\n      );\n    }\n    if (namedInputType === GraphQLBoolean) {\n      return hintList(cur, token, [\n        { text: 'true', type: GraphQLBoolean, description: 'Not false.' }, // TODO: type and description don't seem to be used. Added them as optional anyway.\n        { text: 'false', type: GraphQLBoolean, description: 'Not true.' },\n      ]);\n    }\n  }\n}\n\ninterface VariableTypeInfo {\n  type?: Maybe<GraphQLInputType>;\n  fields?: Maybe<GraphQLInputFieldMap>;\n}\n\n// Utility for collecting rich type information given any token's state\n// from the graphql-variables-mode parser.\nfunction getTypeInfo(\n  variableToType: Record<string, GraphQLInputType>,\n  tokenState: State,\n) {\n  const info: VariableTypeInfo = {\n    type: null,\n    fields: null,\n  };\n\n  forEachState(tokenState, state => {\n    switch (state.kind) {\n      case 'Variable': {\n        info.type = variableToType[state.name!];\n        break;\n      }\n      case 'ListValue': {\n        const nullableType = info.type ? getNullableType(info.type) : undefined;\n        info.type =\n          nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n      }\n      case 'ObjectValue': {\n        const objectType = info.type ? getNamedType(info.type) : undefined;\n        info.fields =\n          objectType instanceof GraphQLInputObjectType\n            ? objectType.getFields()\n            : null;\n        break;\n      }\n      case 'ObjectField': {\n        const objectField =\n          state.name && info.fields ? info.fields[state.name] : null;\n        info.type = objectField?.type;\n        break;\n      }\n    }\n  });\n\n  return info;\n}\n", "/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport type CodeMirror from 'codemirror';\nimport { IHint, IHints } from '../hint';\n\n// Create the expected hint response given a possible list and a token\nexport default function hintList(\n  cursor: CodeMirror.Position,\n  token: CodeMirror.Token,\n  list: IHint[],\n): IHints | undefined {\n  const hints = filterAndSortList(list, normalizeText(token.string));\n  if (!hints) {\n    return;\n  }\n\n  const tokenStart =\n    token.type !== null && /\"|\\w/.test(token.string[0])\n      ? token.start\n      : token.end;\n\n  return {\n    list: hints,\n    from: { line: cursor.line, ch: tokenStart }, // TODO: Confirm. Was changed column to ch\n    to: { line: cursor.line, ch: token.end },\n  };\n}\n\n// Given a list of hint entries and currently typed text, sort and filter to\n// provide a concise list.\nfunction filterAndSortList(list: IHint[], text: string) {\n  if (!text) {\n    return filterNonEmpty(list, entry => !entry.isDeprecated);\n  }\n\n  const byProximity = list.map(entry => ({\n    proximity: getProximity(normalizeText(entry.text), text),\n    entry,\n  }));\n\n  const conciseMatches = filterNonEmpty(\n    filterNonEmpty(byProximity, pair => pair.proximity <= 2),\n    pair => !pair.entry.isDeprecated,\n  );\n\n  const sortedMatches = conciseMatches.sort(\n    (a, b) =>\n      (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) ||\n      a.proximity - b.proximity ||\n      a.entry.text.length - b.entry.text.length,\n  );\n\n  return sortedMatches.map(pair => pair.entry);\n}\n\n// Filters the array by the predicate, unless it results in an empty array,\n// in which case return the original array.\nfunction filterNonEmpty<T>(array: T[], predicate: (item: T) => boolean) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n\nfunction normalizeText(text: string) {\n  return text.toLowerCase().replaceAll(/\\W/g, '');\n}\n\n// Determine a numeric proximity for a suggestion based on current text.\nfunction getProximity(suggestion: string, text: string) {\n  // start with lexical distance\n  let proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    // do not penalize long suggestions.\n    proximity -= suggestion.length - text.length - 1;\n    // penalize suggestions not starting with this phrase\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * This distance can be useful for detecting typos in input or sorting\n *\n * @param {string} a\n * @param {string} b\n * @return {int} distance in number of edits\n */\nfunction lexicalDistance(a: string, b: string) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1,\n        d[i][j - 1] + 1,\n        d[i - 1][j - 1] + cost,\n      );\n\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n\n  return d[aLength][bLength];\n}\n"],
  "mappings": "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",
  "names": ["CodeMirror"]
}
