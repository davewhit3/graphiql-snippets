{
  "version": 3,
  "sources": ["../../.pnpm/codemirror-graphql@2.2.1_@codemirror+language@6.0.0_codemirror@5.65.19_graphql@16.11.0/node_modules/codemirror-graphql/src/variables/lint.ts", "../../.pnpm/codemirror-graphql@2.2.1_@codemirror+language@6.0.0_codemirror@5.65.19_graphql@16.11.0/node_modules/codemirror-graphql/src/utils/jsonParse.ts"],
  "sourcesContent": ["/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport CodeMirror from 'codemirror';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLScalarType,\n  GraphQLType,\n} from 'graphql';\n\nimport jsonParse, {\n  JSONSyntaxError,\n  ParseArrayOutput,\n  ParseObjectOutput,\n  ParseValueOutput,\n} from '../utils/jsonParse';\nimport { VariableToType } from './hint';\n\ninterface GraphQLVariableLintOptions {\n  variableToType: VariableToType;\n}\n\n/**\n * Registers a \"lint\" helper for CodeMirror.\n *\n * Using CodeMirror's \"lint\" addon: https://codemirror.net/demo/lint.html\n * Given the text within an editor, this helper will take that text and return\n * a list of linter issues ensuring that correct variables were provided.\n *\n * Options:\n *\n *   - variableToType: { [variable: string]: GraphQLInputType }\n *\n */\nCodeMirror.registerHelper(\n  'lint',\n  'graphql-variables',\n  (\n    text: string,\n    options: GraphQLVariableLintOptions,\n    editor: CodeMirror.Editor,\n  ) => {\n    // If there's no text, do nothing.\n    if (!text) {\n      return [];\n    }\n\n    // First, linter needs to determine if there are any parsing errors.\n    let ast;\n    try {\n      ast = jsonParse(text);\n    } catch (error) {\n      if (error instanceof JSONSyntaxError) {\n        return [lintError(editor, error.position, error.message)];\n      }\n      throw error;\n    }\n\n    // If there are not yet known variables, do nothing.\n    const { variableToType } = options;\n    if (!variableToType) {\n      return [];\n    }\n\n    // Then highlight any issues with the provided variables.\n    return validateVariables(editor, variableToType, ast);\n  },\n);\n\n// Given a variableToType object, a source text, and a JSON AST, produces a\n// list of CodeMirror annotations for any variable validation errors.\nfunction validateVariables(\n  editor: CodeMirror.Editor,\n  variableToType: VariableToType,\n  variablesAST: ParseObjectOutput,\n) {\n  const errors: CodeMirror.Annotation[] = [];\n\n  for (const member of variablesAST.members) {\n    if (member) {\n      const variableName = member.key?.value;\n      const type = variableToType[variableName];\n      if (type) {\n        for (const [node, message] of validateValue(type, member.value)) {\n          errors.push(lintError(editor, node, message));\n        }\n      } else {\n        errors.push(\n          lintError(\n            editor,\n            member.key!,\n            `Variable \"$${variableName}\" does not appear in any GraphQL query.`,\n          ),\n        );\n      }\n    }\n  }\n\n  return errors;\n}\n\n// Returns a list of validation errors in the form Array<[Node, String]>.\nfunction validateValue(\n  type?: GraphQLType,\n  valueAST?: ParseValueOutput,\n): any[][] {\n  // TODO: Can't figure out the right type.\n  if (!type || !valueAST) {\n    return [];\n  }\n\n  // Validate non-nullable values.\n  if (type instanceof GraphQLNonNull) {\n    if (valueAST.kind === 'Null') {\n      return [[valueAST, `Type \"${type}\" is non-nullable and cannot be null.`]];\n    }\n    return validateValue(type.ofType, valueAST);\n  }\n\n  if (valueAST.kind === 'Null') {\n    return [];\n  }\n\n  // Validate lists of values, accepting a non-list as a list of one.\n  if (type instanceof GraphQLList) {\n    const itemType = type.ofType;\n    if (valueAST.kind === 'Array') {\n      const values = (valueAST as ParseArrayOutput).values || [];\n      return mapCat(values, item => validateValue(itemType, item));\n    }\n    return validateValue(itemType, valueAST);\n  }\n\n  // Validate input objects.\n  if (type instanceof GraphQLInputObjectType) {\n    if (valueAST.kind !== 'Object') {\n      return [[valueAST, `Type \"${type}\" must be an Object.`]];\n    }\n\n    // Validate each field in the input object.\n    const providedFields = Object.create(null);\n    const fieldErrors: any[][] = mapCat(\n      (valueAST as ParseObjectOutput).members,\n      member => {\n        // TODO: Can't figure out the right type here\n        const fieldName = member?.key?.value;\n        providedFields[fieldName] = true;\n        const inputField = type.getFields()[fieldName];\n        if (!inputField) {\n          return [\n            [\n              member.key,\n              `Type \"${type}\" does not have a field \"${fieldName}\".`,\n            ],\n          ];\n        }\n        const fieldType = inputField ? inputField.type : undefined;\n        return validateValue(fieldType, member.value);\n      },\n    );\n\n    // Look for missing non-nullable fields.\n    for (const fieldName of Object.keys(type.getFields())) {\n      const field = type.getFields()[fieldName];\n      if (\n        !providedFields[fieldName] &&\n        field.type instanceof GraphQLNonNull &&\n        !field.defaultValue\n      ) {\n        fieldErrors.push([\n          valueAST,\n          `Object of type \"${type}\" is missing required field \"${fieldName}\".`,\n        ]);\n      }\n    }\n\n    return fieldErrors;\n  }\n\n  // Validate common scalars.\n  if (\n    (type.name === 'Boolean' && valueAST.kind !== 'Boolean') ||\n    (type.name === 'String' && valueAST.kind !== 'String') ||\n    (type.name === 'ID' &&\n      valueAST.kind !== 'Number' &&\n      valueAST.kind !== 'String') ||\n    (type.name === 'Float' && valueAST.kind !== 'Number') ||\n    (type.name === 'Int' &&\n      // eslint-disable-next-line no-bitwise\n      (valueAST.kind !== 'Number' || (valueAST.value | 0) !== valueAST.value))\n  ) {\n    return [[valueAST, `Expected value of type \"${type}\".`]];\n  }\n\n  // Validate enums and custom scalars.\n  if (\n    (type instanceof GraphQLEnumType || type instanceof GraphQLScalarType) &&\n    ((valueAST.kind !== 'String' &&\n      valueAST.kind !== 'Number' &&\n      valueAST.kind !== 'Boolean' &&\n      valueAST.kind !== 'Null') ||\n      isNullish(type.parseValue(valueAST.value)))\n  ) {\n    return [[valueAST, `Expected value of type \"${type}\".`]];\n  }\n\n  return [];\n}\n\n// Give a parent text, an AST node with location, and a message, produces a\n// CodeMirror annotation object.\nfunction lintError(\n  editor: CodeMirror.Editor,\n  node: { start: number; end: number },\n  message: string,\n): CodeMirror.Annotation & { type: string } {\n  return {\n    message,\n    severity: 'error',\n    type: 'validation',\n    from: editor.posFromIndex(node.start),\n    to: editor.posFromIndex(node.end),\n  };\n}\n\nfunction isNullish(value: any): boolean {\n  // eslint-disable-next-line no-self-compare\n  return value === null || value === undefined || value !== value;\n}\n\nfunction mapCat<T, R>(array: T[], mapper: (item: T) => R[]): R[] {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\n", "/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * This JSON parser simply walks the input, generating an AST. Use this in lieu\n * of JSON.parse if you need character offset parse errors and an AST parse tree\n * with location information.\n *\n * If an error is encountered, a SyntaxError will be thrown, with properties:\n *\n *   - message: string\n *   - start: int - the start inclusive offset of the syntax error\n *   - end: int - the end exclusive offset of the syntax error\n *\n */\nexport default function jsonParse(str: string) {\n  string = str;\n  strLen = str.length;\n  start = end = lastEnd = -1;\n  ch();\n  lex();\n  const ast = parseObj();\n  expect('EOF');\n  return ast;\n}\n\nlet string: string;\nlet strLen: number;\nlet start: number;\nlet end: number;\nlet lastEnd: number;\nlet code: number;\nlet kind: string;\n\ninterface BaseParseOutput {\n  kind: string;\n  start: number;\n  end: number;\n}\nexport interface ParseTokenOutput extends BaseParseOutput {\n  value: any;\n}\nexport interface ParseObjectOutput extends BaseParseOutput {\n  kind: 'Object';\n  members: ParseMemberOutput[];\n}\nexport interface ParseArrayOutput extends BaseParseOutput {\n  kind: 'Array';\n  values?: ParseValueOutput[];\n}\nexport interface ParseMemberOutput extends BaseParseOutput {\n  key: ParseTokenOutput | null;\n  value?: ParseValueOutput;\n}\nexport type ParseValueOutput =\n  | ParseTokenOutput\n  | ParseObjectOutput\n  | ParseArrayOutput\n  | undefined;\n\nfunction parseObj(): ParseObjectOutput {\n  const nodeStart = start;\n  const members = [];\n  expect('{');\n  if (!skip('}')) {\n    do {\n      members.push(parseMember());\n    } while (skip(','));\n    expect('}');\n  }\n  return {\n    kind: 'Object',\n    start: nodeStart,\n    end: lastEnd,\n    members,\n  };\n}\n\nfunction parseMember(): ParseMemberOutput {\n  const nodeStart = start;\n  const key = kind === 'String' ? curToken() : null;\n  expect('String');\n  expect(':');\n  const value = parseVal();\n  return {\n    kind: 'Member',\n    start: nodeStart,\n    end: lastEnd,\n    key,\n    value,\n  };\n}\n\nfunction parseArr(): ParseArrayOutput {\n  const nodeStart = start;\n  const values = [];\n  expect('[');\n  if (!skip(']')) {\n    do {\n      values.push(parseVal());\n    } while (skip(','));\n    expect(']');\n  }\n  return {\n    kind: 'Array',\n    start: nodeStart,\n    end: lastEnd,\n    values,\n  };\n}\n\nfunction parseVal(): ParseValueOutput | undefined {\n  switch (kind) {\n    case '[':\n      return parseArr();\n    case '{':\n      return parseObj();\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Null':\n      const token = curToken();\n      lex();\n      return token;\n  }\n  expect('Value');\n}\n\nfunction curToken(): ParseTokenOutput {\n  return { kind, start, end, value: JSON.parse(string.slice(start, end)) };\n}\n\nfunction expect(str: string) {\n  if (kind === str) {\n    lex();\n    return;\n  }\n\n  let found;\n  if (kind === 'EOF') {\n    found = '[end of file]';\n  } else if (end - start > 1) {\n    found = '`' + string.slice(start, end) + '`';\n  } else {\n    const match = string.slice(start).match(/^.+?\\b/);\n    found = '`' + (match ? match[0] : string[start]) + '`';\n  }\n\n  throw syntaxError(`Expected ${str} but found ${found}.`);\n}\n\ntype SyntaxErrorPosition = { start: number; end: number };\n\nexport class JSONSyntaxError extends Error {\n  readonly position: SyntaxErrorPosition;\n  constructor(message: string, position: SyntaxErrorPosition) {\n    super(message);\n    this.position = position;\n  }\n}\n\nfunction syntaxError(message: string) {\n  return new JSONSyntaxError(message, { start, end });\n}\n\nfunction skip(k: string) {\n  if (kind === k) {\n    lex();\n    return true;\n  }\n}\n\nfunction ch() {\n  if (end < strLen) {\n    end++;\n    code = end === strLen ? 0 : string.charCodeAt(end);\n  }\n  return code;\n}\n\nfunction lex() {\n  lastEnd = end;\n\n  while (code === 9 || code === 10 || code === 13 || code === 32) {\n    ch();\n  }\n\n  if (code === 0) {\n    kind = 'EOF';\n    return;\n  }\n\n  start = end;\n\n  switch (code) {\n    // \"\n    case 34:\n      kind = 'String';\n      return readString();\n    // -, 0-9\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      kind = 'Number';\n      return readNumber();\n    // f\n    case 102:\n      if (string.slice(start, start + 5) !== 'false') {\n        break;\n      }\n      end += 4;\n      ch();\n\n      kind = 'Boolean';\n      return;\n    // n\n    case 110:\n      if (string.slice(start, start + 4) !== 'null') {\n        break;\n      }\n      end += 3;\n      ch();\n\n      kind = 'Null';\n      return;\n    // t\n    case 116:\n      if (string.slice(start, start + 4) !== 'true') {\n        break;\n      }\n      end += 3;\n      ch();\n\n      kind = 'Boolean';\n      return;\n  }\n\n  kind = string[start];\n  ch();\n}\n\nfunction readString() {\n  ch();\n  while (code !== 34 && code > 31) {\n    if (code === 92) {\n      // \\\n      code = ch();\n      switch (code) {\n        case 34: // \"\n        case 47: // /\n        case 92: // \\\n        case 98: // b\n        case 102: // f\n        case 110: // n\n        case 114: // r\n        case 116: // t\n          ch();\n          break;\n        case 117: // u\n          ch();\n          readHex();\n          readHex();\n          readHex();\n          readHex();\n          break;\n        default:\n          throw syntaxError('Bad character escape sequence.');\n      }\n    } else if (end === strLen) {\n      throw syntaxError('Unterminated string.');\n    } else {\n      ch();\n    }\n  }\n\n  if (code === 34) {\n    ch();\n    return;\n  }\n\n  throw syntaxError('Unterminated string.');\n}\n\nfunction readHex() {\n  if (\n    (code >= 48 && code <= 57) || // 0-9\n    (code >= 65 && code <= 70) || // A-F\n    (code >= 97 && code <= 102) // a-f\n  ) {\n    return ch();\n  }\n  throw syntaxError('Expected hexadecimal digit.');\n}\n\nfunction readNumber() {\n  if (code === 45) {\n    // -\n    ch();\n  }\n\n  if (code === 48) {\n    // 0\n    ch();\n  } else {\n    readDigits();\n  }\n\n  if (code === 46) {\n    // .\n    ch();\n    readDigits();\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    code = ch();\n    if (code === 43 || code === 45) {\n      // + -\n      ch();\n    }\n    readDigits();\n  }\n}\n\nfunction readDigits() {\n  if (code < 48 || code > 57) {\n    // 0 - 9\n    throw syntaxError('Expected decimal digit.');\n  }\n  do {\n    ch();\n  } while (code >= 48 && code <= 57); // 0 - 9\n}\n"],
  "mappings": "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",
  "names": ["CodeMirror"]
}
