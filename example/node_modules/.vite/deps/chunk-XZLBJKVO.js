// node_modules/.pnpm/meros@1.3.0/node_modules/meros/browser/index.mjs
var e = new TextDecoder();
async function t(t2, n) {
  if (!t2.ok || !t2.body || t2.bodyUsed) return t2;
  let i = t2.headers.get("content-type");
  if (!i || !~i.indexOf("multipart/")) return t2;
  let l = i.indexOf("boundary="), r = "-";
  if (~l) {
    let e2 = l + 9, t3 = i.indexOf(";", e2);
    r = i.slice(e2, t3 > -1 ? t3 : void 0).trim().replace(/"/g, "");
  }
  return async function* (t3, n2, i2) {
    let l2, r2, d, o = t3.getReader(), a = !i2 || !i2.multiple, f = n2.length, s = "", c = [];
    try {
      let t4;
      e: for (; !(t4 = await o.read()).done; ) {
        let i3 = e.decode(t4.value);
        l2 = s.length, s += i3;
        let o2 = i3.indexOf(n2);
        for (~o2 ? l2 += o2 : l2 = s.indexOf(n2), c = []; ~l2; ) {
          let e2 = s.slice(0, l2), t5 = s.slice(l2 + f);
          if (r2) {
            let n3 = e2.indexOf("\r\n\r\n") + 4, i4 = e2.lastIndexOf("\r\n", n3), l3 = false, r3 = e2.slice(n3, i4 > -1 ? void 0 : i4), o3 = String(e2.slice(0, n3)).trim().split("\r\n"), f2 = {}, s2 = o3.length;
            for (; d = o3[--s2]; d = d.split(": "), f2[d.shift().toLowerCase()] = d.join(": ")) ;
            if (d = f2["content-type"], d && ~d.indexOf("application/json")) try {
              r3 = JSON.parse(r3), l3 = true;
            } catch (e3) {
            }
            if (d = { headers: f2, body: r3, json: l3 }, a ? yield d : c.push(d), "--" === t5.slice(0, 2)) break e;
          } else n2 = "\r\n" + n2, r2 = f += 2;
          s = t5, l2 = s.indexOf(n2);
        }
        c.length && (yield c);
      }
    } finally {
      c.length && (yield c), await o.cancel();
    }
  }(t2.body, `--${r}`, n);
}

// node_modules/.pnpm/@n1ru4l+push-pull-async-iterable-iterator@3.2.0/node_modules/@n1ru4l/push-pull-async-iterable-iterator/index.mjs
function withHandlers(source, onReturn, onThrow) {
  const stream = async function* withReturnSource() {
    yield* source;
  }();
  const originalReturn = stream.return.bind(stream);
  if (onReturn) {
    stream.return = (...args) => {
      onReturn();
      return originalReturn(...args);
    };
  }
  if (onThrow) {
    const originalThrow = stream.throw.bind(stream);
    stream.throw = (err) => {
      onThrow(err);
      return originalThrow(err);
    };
  }
  return stream;
}
function createDeferred() {
  const d = {};
  d.promise = new Promise((resolve, reject) => {
    d.resolve = resolve;
    d.reject = reject;
  });
  return d;
}
function makePushPullAsyncIterableIterator() {
  let state = {
    type: "running"
    /* running */
  };
  let next = createDeferred();
  const values = [];
  function pushValue(value) {
    if (state.type !== "running") {
      return;
    }
    values.push(value);
    next.resolve();
    next = createDeferred();
  }
  const source = async function* PushPullAsyncIterableIterator() {
    while (true) {
      if (values.length > 0) {
        yield values.shift();
      } else {
        if (state.type === "error") {
          throw state.error;
        }
        if (state.type === "finished") {
          return;
        }
        await next.promise;
      }
    }
  }();
  const stream = withHandlers(source, () => {
    if (state.type !== "running") {
      return;
    }
    state = {
      type: "finished"
      /* finished */
    };
    next.resolve();
  }, (error) => {
    if (state.type !== "running") {
      return;
    }
    state = {
      type: "error",
      error
    };
    next.resolve();
  });
  return {
    pushValue,
    asyncIterableIterator: stream
  };
}
var makeAsyncIterableIteratorFromSink = (make) => {
  const { pushValue, asyncIterableIterator } = makePushPullAsyncIterableIterator();
  const dispose = make({
    next: (value) => {
      pushValue(value);
    },
    complete: () => {
      asyncIterableIterator.return();
    },
    error: (err) => {
      asyncIterableIterator.throw(err);
    }
  });
  const originalReturn = asyncIterableIterator.return;
  let returnValue = void 0;
  asyncIterableIterator.return = () => {
    if (returnValue === void 0) {
      dispose();
      returnValue = originalReturn();
    }
    return returnValue;
  };
  return asyncIterableIterator;
};
function isAsyncIterable(input) {
  return typeof input === "object" && input !== null && // The AsyncGenerator check is for Safari on iOS which currently does not have
  // Symbol.asyncIterator implemented
  // That means every custom AsyncIterable must be built using a AsyncGeneratorFunction (async function * () {})
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (input[Symbol.toStringTag] === "AsyncGenerator" || Symbol.asyncIterator && Symbol.asyncIterator in input);
}

export {
  t,
  makeAsyncIterableIteratorFromSink,
  isAsyncIterable
};
//# sourceMappingURL=chunk-XZLBJKVO.js.map
